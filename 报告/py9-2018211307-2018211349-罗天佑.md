# Python 程序设计课程大作业

班级：2018211307

学号：2018211349

姓名：罗天佑

# 本地系统

本地系统由 localProxy（本地代理程序）、localGui（图形化界面管理）、UI_localProxy（图形化界面设计）三个程序组成。

localProxy 中程序可以处理 SOCKS5、HTTPS 两种协议下的通信，首先根据收到的包的包头区分两种协议，并调用相应的函数处理连接握手过程。

在完成握手连接后，程序与远端代理建立连接，并开始转发数据包。

localGui 中，程序对 localProxy 程序的参数赋值、传递以及连接建立图形化的表示出来，方便用户的使用。

UI_localProxy 中，程序使用 python 语言描述对图形化界面的设计。

## SOCKS5 服务

```python
async def socks_client(reader, writer, c_header):
    # 读取客户端的报头
    # print(f"c_header:{c_header}")
    assert c_header[0] == SOCKS_VERSION
    assert c_header[1] > 0

    # 获取报头内的方法
    methods = []
    for i in range(c_header[1]):
        methods.append(c_header[2 + i])
    # print(methods)

    if 0 not in set(methods):
        # print("method error")
        return

    # 返回服务端报头
    s_header = struct.pack("!BB", SOCKS_VERSION, 0)
    writer.write(s_header)
    await writer.drain()
    # 完成第一次握手

    # 获取客户端请求报
    request = await reader.read(100)
    # print(f"request:{request}")
    version, cmd, _, address_type = struct.unpack(
        "!BBBB", request[:4])
    assert version == SOCKS_VERSION
    # 对地址类型分类处理
    if address_type == 1:  # IPv4
        address = socket.inet_ntoa(request[4:8])
    elif address_type == 3:  # Domain name
        domain_length = request[4]
        address = request[5:5 + domain_length]
    elif address_type == 4:  # IPv6
        address = socket.inet_ntop(socket.AF_INET6, request[4:20])
    else:
        # print("address_type error")
        return
    # 计算port
    port = request[-2] * 256 + request[-1]
    # print(f"IP:{address}  PORT:{port}")

    # 尝试建立连接
    try:
        if cmd == 1:  # CONNECT
            nreader, nwriter = await asyncio.open_connection(remote_adr.encode(), str(remote_port).encode())
            # print(f'Connected to {address} {port}')

            reploy = "\x05\x00\x00".encode() + request[3:]
        else:
            # print("Cmd wrong")
            return
    # 连接出错返回错误响应
    except Exception as err:
        # print(err)
        # print("Connection Failed")
        reploy = struct.pack("!BBBBIH", SOCKS_VERSION,
                             5, 0, address_type, 0, 0)
        return

    requestToRemote = address + b" " + str(port).encode() + b" " + \
                      str(username).encode() + b" " + str(password).encode()
    nwriter.write(requestToRemote)
    # print(f"requestToRemote:{requestToRemote}")
    await nwriter.drain()

    reployFromRemote = await nreader.read(4096)
    # print(f"reployFromRemote:{reployFromRemote}")
    # 返回响应报
    writer.write(reploy)
    await writer.drain()

    # 符合条件开始交换数据
    if reployFromRemote == b"200":
        await asyncio.gather(server_client(nreader, writer), client_server(reader, nwriter))
    # elif reployFromRemote == b"404":
    #     print("Connection Failed")
    # elif reployFromRemote == b'303':
    #     print("Authentication failed")
    # print("Close the connection")
    writer.close()

```

【文字描述】

根据 SOCKS5 协议，首个字节为 SOCKS_VERSION，下一字节为该次连接的方法个数。获取个数 n，读取后 n 个字符获得方法。由于本程序只要求 CONNECT 方法，即要在方法中找到 CMD X‘01’（即 CONNECT）。之后返回报头完成第一次握手。第二次握手过程中，服务端发送的报文包括地址类型（IPV4、IPV6、Domain name），根据不同的地址类型处理计算出地址，之后获得端口。随后与远端代理建立连接。

连接建立后返回"\x05\x00\x00".encode() + request[3:]（请求报的地址，端口部分字段）。之后就可以将地址端口送到远端代理，从远端建立连接，服务端开始发送数据包，localProxy起到数据中转的作用。

## HTTPS 隧道服务

```python
async def https_client(reader, writer, c_header):
    # print(c_header)
    c_header = c_header.decode()
    request = c_header.split()

    if request[0] == "CONNECT":
        if (request[1][:7] == "http://"):
            addr = request[1]
            port = 80
        else:
            addr = request[1].split(":")[0]
            port = request[1].split(":")[1]
            # print(type(addr), type(port))
        # print(f"Try to Connect: address:{addr} port:{port} ...")

        try:
            # print(type(remote_adr), type(remote_port))
            # print(remote_adr, remote_port)
            nreader, nwriter = await asyncio.open_connection(remote_adr.encode(), str(remote_port).encode())
            # print(f"Connected Success.")
            reploy = b"HTTP/1.1 200 OK\r\n\r\n"
            isConnected = 1

        except Exception:
            # print("Connected failed")
            reploy = b"HTTP/1.1 404 ERROR\r\n\r\n"
            isConnected = -1
            return

        requestToRemote = addr.encode() + b" " + str(port).encode() + b" " + \
                          str(username).encode() + b" " + str(password).encode()
        nwriter.write(requestToRemote)
        # print(f"requestToRemote:{requestToRemote}")
        await nwriter.drain()

        reployFromRemote = await nreader.read(4096)
        # print(f"reployFromRemote:{reployFromRemote}")
        writer.write(reploy)
        await writer.drain()
        # print(reploy)

        # 符合条件开始交换数据
        # print("isConnected", isConnected)
        if reployFromRemote == b"200":
            if isConnected == 1:
                await asyncio.gather(server_client(nreader, writer), client_server(reader, nwriter))
        # elif reployFromRemote == b"404":
        #     print("Connection Failed")
        # elif reployFromRemote == b'303':
        #     print("Authentication failed")
        # print("Close the connection")
        writer.close()
```

【文字描述】

根据 https 协议，首字节为包方法，如果为"CONNECT"就可以计算出地址与端口。送至远端建立连接。相比于 SOCKS5 协议更加简洁。

连接建立后返回b"HTTP/1.1 200 OK\r\n\r\n"。之后就可以将地址端口送到远端代理，从远端建立连接，服务端开始发送数据包，localProxy起到数据中转的作用。

由于 https 使用明文报，因此减少了 decode 环节。但是在向远端传递参数时，应该对参数encode

## 与远端模块通信

```python
# https
requestToRemote = addr.encode() + b" " + str(port).encode() + b" " + str(username).encode() + b" " + str(password).encode()
nwriter.write(requestToRemote)
# print(f"requestToRemote:{requestToRemote}")
await nwriter.drain()

reployFromRemote = await nreader.read(4096)
# print(f"reployFromRemote:{reployFromRemote}")
writer.write(reploy)
await writer.drain()
# print(reploy)

# 符合条件开始交换数据
# print("isConnected", isConnected)
if reployFromRemote == b"200":
    if isConnected == 1:
        await asyncio.gather(server_client(nreader, writer), client_server(reader, nwriter))

async def server_client(nreader, writer):
    while True:
        await asyncio.sleep(0.01)
        message = await nreader.read(4096)
        # print(message)
        await lockRecv.acquire()
        global lenRecv
        lenRecv += len(message)
        # with open("OUT.txt", "a") as sys.stdout:
        #     print(f"lenRecv:{lenRecv}")
        lockRecv.release()
        writer.write(message)
        await writer.drain()
        if len(message) == 0:
            break


async def client_server(reader, nwriter):
    while True:
        await asyncio.sleep(0.01)
        message = await reader.read(4096)
        # print(message)
        await lockSend.acquire()
        global lenSend
        lenSend += len(message)
        # with open("OUT.txt", "a") as sys.stdout:
        #     print(f"lenSend:{lenSend}")
        lockSend.release()
        nwriter.write(message)
        await nwriter.drain()
        if len(message) == 0:
            break
```

【文字描述】

连接建立后，向远端代理发送连接目标地址与端口。由远端代理建立连接。

使用`asyncio.gather`方法开始数据交换。将`server_client(nreader, writer), client_server(reader, nwriter)`两个函数聚集起来，并发执行。实现从服务端到本地代理以及从本地代理到远端代理的双路通信。

对于本地监视流量功能也是在此处实现。通过监视两个通路的发送、接收数据的数据段长度得出。

## 图形管理界面

```python

class MyMainForm(QMainWindow, Ui_Dialog):
    def __init__(self, parent=None):
        super(MyMainForm, self).__init__(parent)
        self.setupUi(self)
        self.remoteAddr = ""
        self.remotePort = int
        self.username = ""
        self.password = ""
        self.consolePort = int
        # self.isConnect = False
        # self.socket = False
        self.StartButton.clicked.connect(self.startProxy)

        self.process = QProcess()
        self.process.setProcessChannelMode(QProcess.MergedChannels)
        self.process.finished.connect(self.processFinished)
        self.process.started.connect(self.processStarted)
        self.process.readyReadStandardOutput.connect(self.processReadyRead)

    def processReadyRead(self):
        data = self.process.readAll()
        try:
            msg = data.data().decode().strip()
            print(f'process msg={msg}')
        except Exception as exc:
            # log.error(f'{traceback.format_exc()}')
            exit(1)

    def processStarted(self):
        process = self.sender()  # 此处等同于 self.process 只不过使用sender适应性更好
        processId = process.processId()
        print(f'started pid={processId}')
        self.StartButton.setText('Stop')
        # QApplication.processEvents()
        # self.processIdLine.setText(str(processId))

        self.websocket = QWebSocket()
        self.websocket.connected.connect(self.websocketConnected)
        self.websocket.disconnected.connect(self.websocketDisconnected)
        self.websocket.textMessageReceived.connect(self.websocketMsgRcvd)
        self.websocket.open(QUrl(f'ws://127.0.0.1:{self.ui_consolePort.text()}/'))

    def startProxy(self):
        if self.StartButton.text() == 'Start':
            self.remoteAddr = self.ui_remoteAddr.text()
            self.remotePort = self.ui_remotePort.text()
            self.username = self.ui_username.text()
            self.password = self.ui_password.text()
            self.consolePort = self.ui_consolePort.text()
            # path = r'C:\Users\18395\PycharmProjects\pithon\localProxy.py'
            path = r'.\localProxy.py'
            # pythonExec = r'C:\Users\18395\PycharmProjects\pithon\venv\Scripts\python.exe'
            pythonExec = os.path.basename(sys.executable)
            # 从localgui启动localproxy直接使用-w 提供用户密码，不再使用命令行交互输入，因为有些许问题
            cmdLine = f'{pythonExec} {path} -u {self.username} -p {self.password} -ra {self.remoteAddr} -rp {self.remotePort} -cp {self.consolePort}'
            print(f'cmd={cmdLine}')

            try:
                f = open('localProxy.bat', mode='w')
                f.write(cmdLine)
                f.close()
                self.process.start("localProxy.bat")
                # os.popen('localProxy.bat')
            except:
                print("can not start")
                exit(1)
        elif self.StartButton.text() == 'Stop':
            self.clean_port(8080)
            self.websocket.disconnect()
            self.process.kill()
            self.StartButton.setText('Start')

    def clean_port(self, port):
        info = os.popen(f"netstat -ano|findstr {port}").read().split()
        for i in range(len(info)):
            if info[i] == "LISTENING":
                pid = info[i + 1]
                print(pid)
                text = os.popen(f"taskkill -pid {pid} -f").read()
                print(text)
                break

    def websocketConnected(self):
        print("connected")
        self.websocket.sendTextMessage('secret')

    def websocketDisconnected(self):
        self.process.kill()

    def processFinished(self):
        self.process.kill()

    def websocketMsgRcvd(self, msg):
        nowTime = QDateTime.currentDateTime().toString('hh:mm:ss')
        print(f'{nowTime}   socket msg={msg}')
        sendBandwidth, recvBandwidth, *_ = msg.split()
        self.ui_up_traffic.setText(f'{(int(sendBandwidth))}')
        self.ui_down_traffic.setText(f'{(int(recvBandwidth))}')

```

【文字描述】

此处打开localProxy功能是借助bat完成的，根据用户输入的参数，写好'localProxy.bat'文件。再通过执行bat文件打开bat文件。

通过setText方法动态的显示上行、下行流量。

关闭代理功能时，使用`os.popen`使用cmd的taskkill命令实现关闭端口，使用`self.websocket.disconnect()`关闭websocket，使用`self.process.kill()`关闭进程。

# 远端系统

【文字描述】

远端模块分为远端代理（remoteProxy）、远端数据库管理（remoteProxyAdmin）两个程序

远端代理对本地代理发来的用户进行验证，再对目标地址、端口进行连接。连接建立后开始与本地代理交换数据。同时在数据交换过程中，有令牌桶流控机制。

## 与本地模块通信

```python
async def main():
    await dbinit()
    server = await asyncio.start_server(
        handle_echo, '127.0.0.1', 8848)
    addr = server.sockets[0].getsockname()
    print(f'Serving on {addr}')
    async with server:
        await server.serve_forever()
```

【文字描述】
`await server.serve_forever()`方法中只要本地代理向远端代理发送连接请求，远端就会开启一个线程调用 handle_echo函数。

## 多用户管理

```python
# 查找该用户是否已经被登记
isVised = -1
for i in range(len(vised)):
    if username == vised[i].name:
        isVised = i
        print("Verified username:", username)
        isUser = 1
        break
else:
    async with aiosqlite.connect(r'E:\Git\Python\Project\connect.db') as db:
        async with db.execute(f"SELECT password,Bandwidth FROM user where username='{username}'") as cursor:
            async for row in cursor:
                if password == row[0]:
                    print("new user")
                    # 创建一个新用户
                    newUser = item()
                    # print(newUser.lock.locked())
                    newUser.name = username
                    newUser.Bandwidth = row[1]
                    # 初始化令牌桶
                    newUser.Token_bucket = Max_Token
                    # 登记该新用户
                    vised.append(newUser)
                    # 操作令牌桶
                    await add_Token(newUser)

                    print("Authentication username:", username)
                    isUser = 1
                    break
```

【文字描述】

本地代理会向远端代理传递建立连接的用户名称与密码，远端代理会维护一个已连接的用户列表。

对于已经建立过连接的用户无需再次在数据库中查询。

对于新用户，数据库会在数据库中使用sql语句查询对应的用户数据，再检查密码与数据库中代码是否相同。如果相同则说明验证成功。同时向用户列表添加此用户。

发现新用户的同时会新建一个该用户的令牌桶，以实现令牌桶的流控。

## 用户流控

```python
async def add_Token(user):
    start = time.time()
    while True:
        await asyncio.sleep(0.01)
        cur = time.time()
        if(user.lock.locked() == True):
            print("add lock state:", user.lock.locked())
        await user.lock.acquire()
        if(cur-start > 0.01):
            if(user.Token_bucket+user.Bandwidth/100 < Max_Token):
                user.Token_bucket += user.Bandwidth/100
            else:
                user.Token_bucket = Max_Token
            # print("Token_bucket after add:", user.Token_bucket)
            start = cur
        user.lock.release()


async def server_client(nreader, writer, user):
    while True:
        sflag = 0
        message = await nreader.read(40000)
        if len(message) == 0:
            break
        while sflag == 0:
            await asyncio.sleep(0.01)
            await user.lock.acquire()
            if(user.Token_bucket > len(message)):
                # print("Tolocal")
                writer.write(message)
                await writer.drain()
                user.Token_bucket -= len(message)
                # print("Token_bucket after read:", user.Token_bucket)
                sflag = 1
            user.lock.release()


async def client_server(reader, nwriter, user):
    while True:
        cflag = 0
        message = await reader.read(40000)
        if len(message) == 0:
            break
        while cflag == 0:
            await asyncio.sleep(0.01)
            await user.lock.acquire()
            if(user.Token_bucket > len(message)):
                # print("ToWWW")
                nwriter.write(message)
                await nwriter.drain()
                user.Token_bucket -= len(message)
                # print("Token_bucket after witer:", user.Token_bucket)
                cflag = 1
            user.lock.release()


```

【文字描述】
`async def add_Token(user)`在新建用户时调用由于使用await可以在之后的过程中与remoteProxy并发执行，以实现令牌桶不断添加令牌的功能。

在交换数据报时`async def server_client(nreader, writer, user):`以及`async def client_server(reader, nwriter, user):`每次交换数据就将令牌桶中减去相应的令牌。

当令牌不够时，会在while循环中忙等待。直到令牌足以完成此次数据交换。


## 用户数据库管理接口

```python
from sanic import Sanic
from sanic.response import *
from sanic.exceptions import *
import aiosqlite

app=Sanic('remoteProxyAdmin')
dbName=r'E:\Git\Python\Project\connect.db'
# app.config.DB_NAME='connect.db'

@app.route('/')
async def test(req):
    return text('Hello World!')

@app.get("/user")
async def getAllUserInfo(req):
    user=[]
    async with aiosqlite.connect(dbName) as db:
        async with db.execute("select username,password,Bandwidth from user") as cusor:
            async for row in cusor:
                tmp = {'username': row[0], 'passwd': row[1], 'Bandwidth': row[2]}
                user.append(tmp)
    return json(user)

@app.get('/user/<username>')
async def getOneUserInfo(req,username):
    async with aiosqlite.connect(dbName) as db:
        async with db.execute(f"select username,password,Bandwidth from user where username=\'{username}\'") as cusor:
            async for row in cusor:
                tmp = {'username': row[0], 'password': row[1], 'Bandwidth': row[2]}
                return json(tmp)

@app.post("/user")
async def addUser(req):
    username=req.json.get('username')
    password=req.json.get('password')
    Bandwidth=req.json.get('Bandwidth')
    print(f"username:{username},password:{password},Bandwidth:{Bandwidth}")
    try:
        async with aiosqlite.connect(dbName) as db:
            await db.execute(f"insert into user values(\'{username}\',\'{password}\',\'{Bandwidth}\')")
            await db.commit()
    except Exception as e:
        return text(f"{e}. when add new user {username}",status=500)
    return text(f"Successfully add new user {username}")

@app.put('/user/<username>')
async def updateUser(req, username):
    oldPassword = req.json.get('oldPassword')
    newPassword = req.json.get('newPassword')
    newBandwidth= req.json.get('newBandwidth')
    print(f"oldPassword:{oldPassword},newPassword:{newPassword},newBandwidth:{newBandwidth}")
    async with aiosqlite.connect(dbName) as db:
        async with db.execute(f"select password from user where username=\'{username}\'")as cusor:
            async for row in cusor:
                if row[0] != oldPassword:
                    return text("password can not match. You have no right to update", status=405)
                else:
                    if not newBandwidth and newPassword:
                        await db.execute(f"update user set password=\'{newPassword}\'where username=\'{username}\'")
                    elif not newPassword and newBandwidth:
                        await db.execute(f"update user set Bandwidth=\'{newBandwidth}\' where username=\'{username}\'")
                    elif newPassword and newBandwidth:
                        await db.execute(f"update user set Bandwidth=\'{newBandwidth}\',password=\'{newPassword}\' where username=\'{username}\'")
                    else:
                        return text(f"Successfully update user: {username}.but you update nothing.")
                    await db.commit()
                    return text(f"Successfully update user: {username}")
            else:
                return text(f"Can not find user: {username}",status=404)

@app.delete('/user/<username>') #删除用户
async def delete_user(req, username):
    password = req.json.get('password')
    async with aiosqlite.connect(dbName) as db:
        async with db.execute(f"select password from user where username=\'{username}\'")as cusor:
            async for row in cusor:
                if row[0] != password:
                    return text("password can not match. You have no right to delect", status=405)
                else:
                    await db.execute(f"delete from user where username=\'{username}\'")
                    await db.commit()
                    return text(f"Successfully update user: {username}")
            else:
                return text(f"Can not find user: {username}",status=404)

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=8000)

```

【文字描述】

本程序使用sanic库实现数据库管理，通过使用get、post、put、delete可以实现数据库的增删改查。使用注释规定了app的行为。本程序中主要使用sql语句对数据库进行操作。

# 程序完整源码

localProxy.py

```python
import asyncio
import socket
import struct
import argparse
import websockets
import sys
import time

SOCKS_VERSION = 5
remote_adr = ' '
remote_port = 0
consolePort = 0
username = ' '
password = ' '
gRecvBandwidth = 0
gSendBandwidth = 0
lenRecv = 0
lenSend = 0
lockRecv = asyncio.Lock()
lockSend = asyncio.Lock()


async def localConsole(ws, path):
    try:
        while True:
            global gSendBandwidth
            global gRecvBandwidth
            await asyncio.sleep(2)
            # with open("OUT.txt", "a") as sys.stdout:
            #     print(f"Send to GUI: gSendBandwidth:{gSendBandwidth}   gRecvBandwidth:{gRecvBandwidth}")
            msg = await ws.send(f'{gSendBandwidth} {gRecvBandwidth}')
    except Exception:
        exit(1)

async def calcBandwidth():
    start = time.time()
    while True:
        global gRecvBandwidth, gSendBandwidth
        global lenRecv, lenSend
        await asyncio.sleep(2)
        await lockRecv.acquire()
        await lockSend.acquire()
        cur = time.time()
        if (cur - start >= 2):
            # with open("OUT.txt", "a") as sys.stdout:
            #     print(f"calcBandwidth: lenRecv:{lenRecv}   lenSend:{lenSend}")

            gRecvBandwidth = round(lenRecv / (cur - start))

            gSendBandwidth = round(lenSend / (cur - start))

            lenRecv = 0
            lenSend = 0
            start = cur
        lockRecv.release()
        lockSend.release()


async def server_client(nreader, writer):
    while True:
        await asyncio.sleep(0.01)
        message = await nreader.read(4096)
        # print(message)
        await lockRecv.acquire()
        global lenRecv
        lenRecv += len(message)
        # with open("OUT.txt", "a") as sys.stdout:
        #     print(f"lenRecv:{lenRecv}")
        lockRecv.release()
        writer.write(message)
        await writer.drain()
        if len(message) == 0:
            break


async def client_server(reader, nwriter):
    while True:
        await asyncio.sleep(0.01)
        message = await reader.read(4096)
        # print(message)
        await lockSend.acquire()
        global lenSend
        lenSend += len(message)
        # with open("OUT.txt", "a") as sys.stdout:
        #     print(f"lenSend:{lenSend}")
        lockSend.release()
        nwriter.write(message)
        await nwriter.drain()
        if len(message) == 0:
            break


async def https_client(reader, writer, c_header):
    # print(c_header)
    c_header = c_header.decode()
    request = c_header.split()

    if request[0] == "CONNECT":
        if (request[1][:7] == "http://"):
            addr = request[1]
            port = 80
        else:
            addr = request[1].split(":")[0]
            port = request[1].split(":")[1]
            # print(type(addr), type(port))
        # print(f"Try to Connect: address:{addr} port:{port} ...")

        try:
            # print(type(remote_adr), type(remote_port))
            # print(remote_adr, remote_port)
            nreader, nwriter = await asyncio.open_connection(remote_adr.encode(), str(remote_port).encode())
            # print(f"Connected Success.")
            reploy = b"HTTP/1.1 200 OK\r\n\r\n"
            isConnected = 1

        except Exception:
            # print("Connected failed")
            reploy = b"HTTP/1.1 404 ERROR\r\n\r\n"
            isConnected = -1
            return

        requestToRemote = addr.encode() + b" " + str(port).encode() + b" " + \
                          str(username).encode() + b" " + str(password).encode()
        nwriter.write(requestToRemote)
        # print(f"requestToRemote:{requestToRemote}")
        await nwriter.drain()

        reployFromRemote = await nreader.read(4096)
        # print(f"reployFromRemote:{reployFromRemote}")
        writer.write(reploy)
        await writer.drain()
        # print(reploy)

        # 符合条件开始交换数据
        # print("isConnected", isConnected)
        if reployFromRemote == b"200":
            if isConnected == 1:
                await asyncio.gather(server_client(nreader, writer), client_server(reader, nwriter))
        # elif reployFromRemote == b"404":
        #     print("Connection Failed")
        # elif reployFromRemote == b'303':
        #     print("Authentication failed")
        # print("Close the connection")
        writer.close()


async def socks_client(reader, writer, c_header):
    # 读取客户端的报头
    # print(f"c_header:{c_header}")
    assert c_header[0] == SOCKS_VERSION
    assert c_header[1] > 0

    # 获取报头内的方法
    methods = []
    for i in range(c_header[1]):
        methods.append(c_header[2 + i])
    # print(methods)

    if 0 not in set(methods):
        # print("method error")
        return

    # 返回服务端报头
    s_header = struct.pack("!BB", SOCKS_VERSION, 0)
    writer.write(s_header)
    await writer.drain()
    # 完成第一次握手

    # 获取客户端请求报
    request = await reader.read(100)
    # print(f"request:{request}")
    version, cmd, _, address_type = struct.unpack(
        "!BBBB", request[:4])
    assert version == SOCKS_VERSION
    # 对地址类型分类处理
    if address_type == 1:  # IPv4
        address = socket.inet_ntoa(request[4:8])
    elif address_type == 3:  # Domain name
        domain_length = request[4]
        address = request[5:5 + domain_length]
    elif address_type == 4:  # IPv6
        address = socket.inet_ntop(socket.AF_INET6, request[4:20])
    else:
        # print("address_type error")
        return
    # 计算port
    port = request[-2] * 256 + request[-1]
    # print(f"IP:{address}  PORT:{port}")

    # 尝试建立连接
    try:
        if cmd == 1:  # CONNECT
            nreader, nwriter = await asyncio.open_connection(remote_adr.encode(), str(remote_port).encode())
            # print(f'Connected to {address} {port}')

            reploy = "\x05\x00\x00".encode() + request[3:]
        else:
            # print("Cmd wrong")
            return
    # 连接出错返回错误响应
    except Exception as err:
        # print(err)
        # print("Connection Failed")
        reploy = struct.pack("!BBBBIH", SOCKS_VERSION,
                             5, 0, address_type, 0, 0)
        return

    requestToRemote = address + b" " + str(port).encode() + b" " + \
                      str(username).encode() + b" " + str(password).encode()
    nwriter.write(requestToRemote)
    # print(f"requestToRemote:{requestToRemote}")
    await nwriter.drain()

    reployFromRemote = await nreader.read(4096)
    # print(f"reployFromRemote:{reployFromRemote}")
    # 返回响应报
    writer.write(reploy)
    await writer.drain()

    # 符合条件开始交换数据
    if reployFromRemote == b"200":
        await asyncio.gather(server_client(nreader, writer), client_server(reader, nwriter))
    # elif reployFromRemote == b"404":
    #     print("Connection Failed")
    # elif reployFromRemote == b'303':
    #     print("Authentication failed")
    # print("Close the connection")
    writer.close()


async def selectProtocol(reader, writer):
    c_header = await reader.read(4096)
    if (len(c_header) <= 5 and c_header[0] == SOCKS_VERSION):
        # print("Protocol:socks5")
        await socks_client(reader, writer, c_header)
    else:
        # print("Protocol:HTTP")
        await https_client(reader, writer, c_header)


async def main():
    if consolePort:  # 这是localproxy的websocket监听端口
        # with open("OUT.txt", "a") as sys.stdout:
        #     print("gui connect localproxy")
        ws_server = await websockets.serve(localConsole, '127.0.0.1', consolePort)
        # with open("OUT.txt", "a") as sys.stdout:
        #     print("served")

    asyncio.create_task(calcBandwidth())

    server = await asyncio.start_server(selectProtocol, '127.0.0.1', 8080)
    async with server:
        await server.serve_forever()


parser = argparse.ArgumentParser()
parser.add_argument("-ra", dest="remote_adr")
parser.add_argument("-rp", dest="remote_port")
parser.add_argument("-cp", dest="consolePort")
parser.add_argument("-u", dest="username")
parser.add_argument("-p", dest="password")
args = parser.parse_args()
username = args.username
password = args.password
consolePort = args.consolePort
remote_adr = args.remote_adr
remote_port = args.remote_port
asyncio.run(main())

```

localGui.py

```python
import os
import sys
import websockets

from PyQt5.QtCore import *
from PyQt5.QtWebSockets import *
from PyQt5.QtWidgets import *
from UI_localProxy import *


class MyMainForm(QMainWindow, Ui_Dialog):
    def __init__(self, parent=None):
        super(MyMainForm, self).__init__(parent)
        self.setupUi(self)
        self.remoteAddr = ""
        self.remotePort = int
        self.username = ""
        self.password = ""
        self.consolePort = int
        # self.isConnect = False
        # self.socket = False
        self.StartButton.clicked.connect(self.startProxy)

        self.process = QProcess()
        self.process.setProcessChannelMode(QProcess.MergedChannels)
        self.process.finished.connect(self.processFinished)
        self.process.started.connect(self.processStarted)
        self.process.readyReadStandardOutput.connect(self.processReadyRead)

    def processReadyRead(self):
        data = self.process.readAll()
        try:
            msg = data.data().decode().strip()
            print(f'process msg={msg}')
        except Exception as exc:
            # log.error(f'{traceback.format_exc()}')
            exit(1)

    def processStarted(self):
        process = self.sender()  # 此处等同于 self.process 只不过使用sender适应性更好
        processId = process.processId()
        print(f'started pid={processId}')
        self.StartButton.setText('Stop')
        # QApplication.processEvents()
        # self.processIdLine.setText(str(processId))

        self.websocket = QWebSocket()
        self.websocket.connected.connect(self.websocketConnected)
        self.websocket.disconnected.connect(self.websocketDisconnected)
        self.websocket.textMessageReceived.connect(self.websocketMsgRcvd)
        self.websocket.open(QUrl(f'ws://127.0.0.1:{self.ui_consolePort.text()}/'))

    def startProxy(self):
        if self.StartButton.text() == 'Start':
            self.remoteAddr = self.ui_remoteAddr.text()
            self.remotePort = self.ui_remotePort.text()
            self.username = self.ui_username.text()
            self.password = self.ui_password.text()
            self.consolePort = self.ui_consolePort.text()
            # path = r'C:\Users\18395\PycharmProjects\pithon\localProxy.py'
            path = r'.\localProxy.py'
            # pythonExec = r'C:\Users\18395\PycharmProjects\pithon\venv\Scripts\python.exe'
            pythonExec = os.path.basename(sys.executable)
            # 从localgui启动localproxy直接使用-w 提供用户密码，不再使用命令行交互输入，因为有些许问题
            cmdLine = f'{pythonExec} {path} -u {self.username} -p {self.password} -ra {self.remoteAddr} -rp {self.remotePort} -cp {self.consolePort}'
            print(f'cmd={cmdLine}')

            try:
                f = open('localProxy.bat', mode='w')
                f.write(cmdLine)
                f.close()
                self.process.start("localProxy.bat")
                # os.popen('localProxy.bat')
            except:
                print("can not start")
                exit(1)
        elif self.StartButton.text() == 'Stop':
            self.clean_port(8080)
            self.websocket.disconnect()
            self.process.kill()
            self.StartButton.setText('Start')

    def clean_port(self, port):
        info = os.popen(f"netstat -ano|findstr {port}").read().split()
        for i in range(len(info)):
            if info[i] == "LISTENING":
                pid = info[i + 1]
                print(pid)
                text = os.popen(f"taskkill -pid {pid} -f").read()
                print(text)
                break

    def websocketConnected(self):
        print("connected")
        self.websocket.sendTextMessage('secret')

    def websocketDisconnected(self):
        self.process.kill()

    def processFinished(self):
        self.process.kill()

    def websocketMsgRcvd(self, msg):
        nowTime = QDateTime.currentDateTime().toString('hh:mm:ss')
        print(f'{nowTime}   socket msg={msg}')
        sendBandwidth, recvBandwidth, *_ = msg.split()
        self.ui_up_traffic.setText(f'{(int(sendBandwidth))}')
        self.ui_down_traffic.setText(f'{(int(recvBandwidth))}')


def main():
    app = QApplication(sys.argv)
    myWin = MyMainForm()
    myWin.show()
    sys.exit(app.exec_())


if __name__ == '__main__':
    main()

```

UI_localProxy.py

```python
from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(540, 630)
        Dialog.setMinimumSize(QtCore.QSize(540, 630))
        Dialog.setMaximumSize(QtCore.QSize(540, 630))
        self.layoutWidget = QtWidgets.QWidget(Dialog)
        self.layoutWidget.setGeometry(QtCore.QRect(11, 11, 518, 606))
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        spacerItem = QtWidgets.QSpacerItem(20, 21, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem)
        self.label_5 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("楷体")
        font.setPointSize(24)
        self.label_5.setFont(font)
        self.label_5.setAlignment(QtCore.Qt.AlignCenter)
        self.label_5.setObjectName("label_5")
        self.verticalLayout.addWidget(self.label_5)
        spacerItem1 = QtWidgets.QSpacerItem(20, 22, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem2)
        self.label = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem3)
        self.ui_remoteAddr = QtWidgets.QLineEdit(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.ui_remoteAddr.setFont(font)
        self.ui_remoteAddr.setObjectName("ui_remoteAddr")
        self.horizontalLayout.addWidget(self.ui_remoteAddr)
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem4)
        self.horizontalLayout.setStretch(0, 1)
        self.horizontalLayout.setStretch(1, 3)
        self.horizontalLayout.setStretch(2, 1)
        self.horizontalLayout.setStretch(3, 5)
        self.horizontalLayout.setStretch(4, 1)
        self.verticalLayout.addLayout(self.horizontalLayout)
        spacerItem5 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem5)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem6)
        self.label_2 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label_2.setFont(font)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_2.addWidget(self.label_2)
        spacerItem7 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem7)
        self.ui_remotePort = QtWidgets.QLineEdit(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.ui_remotePort.setFont(font)
        self.ui_remotePort.setObjectName("ui_remotePort")
        self.horizontalLayout_2.addWidget(self.ui_remotePort)
        spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem8)
        self.horizontalLayout_2.setStretch(0, 1)
        self.horizontalLayout_2.setStretch(1, 3)
        self.horizontalLayout_2.setStretch(2, 1)
        self.horizontalLayout_2.setStretch(3, 5)
        self.horizontalLayout_2.setStretch(4, 1)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        spacerItem9 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem9)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        spacerItem10 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem10)
        self.label_8 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label_8.setFont(font)
        self.label_8.setObjectName("label_8")
        self.horizontalLayout_3.addWidget(self.label_8)
        spacerItem11 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem11)
        self.ui_consolePort = QtWidgets.QLineEdit(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.ui_consolePort.setFont(font)
        self.ui_consolePort.setObjectName("ui_consolePort")
        self.horizontalLayout_3.addWidget(self.ui_consolePort)
        spacerItem12 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem12)
        self.horizontalLayout_3.setStretch(0, 1)
        self.horizontalLayout_3.setStretch(1, 3)
        self.horizontalLayout_3.setStretch(2, 1)
        self.horizontalLayout_3.setStretch(3, 5)
        self.horizontalLayout_3.setStretch(4, 1)
        self.verticalLayout.addLayout(self.horizontalLayout_3)
        spacerItem13 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem13)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        spacerItem14 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem14)
        self.label_3 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_4.addWidget(self.label_3)
        spacerItem15 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem15)
        self.ui_username = QtWidgets.QLineEdit(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.ui_username.setFont(font)
        self.ui_username.setObjectName("ui_username")
        self.horizontalLayout_4.addWidget(self.ui_username)
        spacerItem16 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem16)
        self.horizontalLayout_4.setStretch(0, 1)
        self.horizontalLayout_4.setStretch(1, 3)
        self.horizontalLayout_4.setStretch(2, 1)
        self.horizontalLayout_4.setStretch(3, 5)
        self.horizontalLayout_4.setStretch(4, 1)
        self.verticalLayout.addLayout(self.horizontalLayout_4)
        spacerItem17 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem17)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        spacerItem18 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem18)
        self.label_4 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label_4.setFont(font)
        self.label_4.setObjectName("label_4")
        self.horizontalLayout_5.addWidget(self.label_4)
        spacerItem19 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem19)
        self.ui_password = QtWidgets.QLineEdit(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.ui_password.setFont(font)
        self.ui_password.setEchoMode(QtWidgets.QLineEdit.PasswordEchoOnEdit)
        self.ui_password.setObjectName("ui_password")
        self.horizontalLayout_5.addWidget(self.ui_password)
        spacerItem20 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem20)
        self.horizontalLayout_5.setStretch(0, 1)
        self.horizontalLayout_5.setStretch(1, 3)
        self.horizontalLayout_5.setStretch(2, 1)
        self.horizontalLayout_5.setStretch(3, 5)
        self.horizontalLayout_5.setStretch(4, 1)
        self.verticalLayout.addLayout(self.horizontalLayout_5)
        spacerItem21 = QtWidgets.QSpacerItem(20, 21, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem21)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        spacerItem22 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem22)
        self.StartButton = QtWidgets.QPushButton(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(18)
        self.StartButton.setFont(font)
        self.StartButton.setObjectName("StartButton")
        self.horizontalLayout_8.addWidget(self.StartButton)
        spacerItem23 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem23)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.label_6 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label_6.setFont(font)
        self.label_6.setObjectName("label_6")
        self.horizontalLayout_6.addWidget(self.label_6)
        spacerItem24 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem24)
        self.ui_up_traffic = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.ui_up_traffic.setFont(font)
        self.ui_up_traffic.setObjectName("ui_up_traffic")
        self.horizontalLayout_6.addWidget(self.ui_up_traffic)
        spacerItem25 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem25)
        self.label_9 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label_9.setFont(font)
        self.label_9.setObjectName("label_9")
        self.horizontalLayout_6.addWidget(self.label_9)
        self.horizontalLayout_6.setStretch(0, 6)
        self.horizontalLayout_6.setStretch(1, 1)
        self.horizontalLayout_6.setStretch(2, 2)
        self.horizontalLayout_6.setStretch(3, 1)
        self.horizontalLayout_6.setStretch(4, 2)
        self.verticalLayout_2.addLayout(self.horizontalLayout_6)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.label_7 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label_7.setFont(font)
        self.label_7.setObjectName("label_7")
        self.horizontalLayout_7.addWidget(self.label_7)
        spacerItem26 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_7.addItem(spacerItem26)
        self.ui_down_traffic = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.ui_down_traffic.setFont(font)
        self.ui_down_traffic.setObjectName("ui_down_traffic")
        self.horizontalLayout_7.addWidget(self.ui_down_traffic)
        spacerItem27 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_7.addItem(spacerItem27)
        self.label_10 = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("等线")
        font.setPointSize(12)
        self.label_10.setFont(font)
        self.label_10.setObjectName("label_10")
        self.horizontalLayout_7.addWidget(self.label_10)
        self.horizontalLayout_7.setStretch(0, 6)
        self.horizontalLayout_7.setStretch(1, 1)
        self.horizontalLayout_7.setStretch(2, 2)
        self.horizontalLayout_7.setStretch(3, 1)
        self.horizontalLayout_7.setStretch(4, 2)
        self.verticalLayout_2.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_8.addLayout(self.verticalLayout_2)
        spacerItem28 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem28)
        self.verticalLayout.addLayout(self.horizontalLayout_8)
        spacerItem29 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem29)
        self.verticalLayout.setStretch(0, 1)
        self.verticalLayout.setStretch(1, 3)
        self.verticalLayout.setStretch(2, 1)
        self.verticalLayout.setStretch(3, 3)
        self.verticalLayout.setStretch(4, 1)
        self.verticalLayout.setStretch(5, 3)
        self.verticalLayout.setStretch(6, 1)
        self.verticalLayout.setStretch(7, 3)
        self.verticalLayout.setStretch(8, 1)
        self.verticalLayout.setStretch(9, 3)
        self.verticalLayout.setStretch(10, 1)
        self.verticalLayout.setStretch(11, 3)
        self.verticalLayout.setStretch(12, 1)
        self.verticalLayout.setStretch(13, 3)
        self.verticalLayout.setStretch(14, 1)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.label_5.setText(_translate("Dialog", "NANAIII PROXY"))
        self.label.setText(_translate("Dialog", "Proxy Address"))
        self.ui_remoteAddr.setText(_translate("Dialog", "127.0.0.1"))
        self.label_2.setText(_translate("Dialog", "Proxy Port"))
        self.ui_remotePort.setText(_translate("Dialog", "8848"))
        self.label_8.setText(_translate("Dialog", "consolePort"))
        self.ui_consolePort.setText(_translate("Dialog", "2020"))
        self.label_3.setText(_translate("Dialog", "username"))
        self.ui_username.setText(_translate("Dialog", "lty"))
        self.label_4.setText(_translate("Dialog", "password"))
        self.ui_password.setText(_translate("Dialog", "2018211349"))
        self.StartButton.setText(_translate("Dialog", "Start"))
        self.label_6.setText(_translate("Dialog", "Uptraffic"))
        self.ui_up_traffic.setText(_translate("Dialog", "XXX"))
        self.label_9.setText(_translate("Dialog", "Ｂ／ｓ"))
        self.label_7.setText(_translate("Dialog", "Downtraffic"))
        self.ui_down_traffic.setText(_translate("Dialog", "XXX"))
        self.label_10.setText(_translate("Dialog", "Ｂ／ｓ"))

```

remoteProxy.py

```python
import asyncio
import socket
import struct
import aiosqlite
import time
Max_Token = 200000
vised = []


class item:
    def __init__(self):
        super().__init__()
        self.name = " "
        self.Bandwidth = 0
        self.Token_bucket = 0
        self.lock = asyncio.Lock()


async def dbinit():
    async with aiosqlite.connect(r'E:\Git\Python\Project\connect.db') as db:
        try:
            await db.execute("CREATE TABLE user (username text primary key, password text not null,Bandwidth int)")
        except Exception as e:
            await db.execute("drop table user")
            await db.execute("CREATE TABLE user (username text primary key, password text not null,Bandwidth int)")
        await db.execute("INSERT INTO user (username,password,Bandwidth) VALUES('lty', '2018211349',1000000)")
        await db.execute("INSERT INTO user (username,password,Bandwidth) VALUES('zzl', '2018211346',2000000)")
        await db.execute("INSERT INTO user (username,password,Bandwidth) VALUES('hzz', '2018211362',3000000)")
        await db.commit()


async def add_Token(user):
    start = time.time()
    while True:
        await asyncio.sleep(0.01)
        cur = time.time()
        if(user.lock.locked() == True):
            print("add lock state:", user.lock.locked())
        await user.lock.acquire()
        if(cur-start > 0.01):
            if(user.Token_bucket+user.Bandwidth/100 < Max_Token):
                user.Token_bucket += user.Bandwidth/100
            else:
                user.Token_bucket = Max_Token
            # print("Token_bucket after add:", user.Token_bucket)
            start = cur
        user.lock.release()


async def server_client(nreader, writer, user):
    while True:
        sflag = 0
        message = await nreader.read(40000)
        if len(message) == 0:
            break
        while sflag == 0:
            await asyncio.sleep(0.01)
            await user.lock.acquire()
            if(user.Token_bucket > len(message)):
                # print("Tolocal")
                writer.write(message)
                await writer.drain()
                user.Token_bucket -= len(message)
                # print("Token_bucket after read:", user.Token_bucket)
                sflag = 1
            user.lock.release()


async def client_server(reader, nwriter, user):
    while True:
        cflag = 0
        message = await reader.read(40000)
        if len(message) == 0:
            break
        while cflag == 0:
            await asyncio.sleep(0.01)
            await user.lock.acquire()
            if(user.Token_bucket > len(message)):
                # print("ToWWW")
                nwriter.write(message)
                await nwriter.drain()
                user.Token_bucket -= len(message)
                # print("Token_bucket after witer:", user.Token_bucket)
                cflag = 1
            user.lock.release()


async def handle_echo(reader, writer):

    addr = writer.get_extra_info('peername')
    print(f"request from:{addr}")
    data = await reader.read(4096)
    message = data.decode().split()
    print(f"message:{message}")
    username = message[2]
    password = message[3]
    isUser = 0

    # 查找该用户是否已经被登记
    isVised = -1
    for i in range(len(vised)):
        if username == vised[i].name:
            isVised = i
            print("Verified username:", username)
            isUser = 1
            break
    else:
        async with aiosqlite.connect(r'E:\Git\Python\Project\connect.db') as db:
            async with db.execute(f"SELECT password,Bandwidth FROM user where username='{username}'") as cursor:
                async for row in cursor:
                    if password == row[0]:
                        print("new user")
                        # 创建一个新用户
                        newUser = item()
                        # print(newUser.lock.locked())
                        newUser.name = username
                        newUser.Bandwidth = row[1]
                        # 初始化令牌桶
                        newUser.Token_bucket = Max_Token
                        # 登记该新用户
                        vised.append(newUser)
                        # 操作令牌桶
                        await add_Token(newUser)

                        print("Authentication username:", username)
                        isUser = 1
                        break

    if isUser == 1:
        try:
            nreader, nwriter = await asyncio.open_connection(host=message[0], port=message[1])
            print(f'Connected to {message[0]} {message[1]}')
            reploy = b"200"
        except:
            print("Connected failed \n")
            reploy = b"404"
        writer.write(reploy)
        await writer.drain()
        if reploy == b'200':
            await asyncio.gather(server_client(nreader, writer, vised[isVised]), client_server(reader, nwriter, vised[isVised]))
    else:
        reploy = b'303'
        writer.write(reploy)
        await writer.drain()
        print("Authentication failed")

    print("Close the connection \n")
    writer.close()


async def main():
    await dbinit()
    server = await asyncio.start_server(
        handle_echo, '127.0.0.1', 8848)
    addr = server.sockets[0].getsockname()
    print(f'Serving on {addr}')
    async with server:
        await server.serve_forever()

asyncio.run(main())

```

remoteProxyAdmin.py

```python
from sanic import Sanic
from sanic.response import *
from sanic.exceptions import *
import aiosqlite

app=Sanic('remoteProxyAdmin')
dbName=r'E:\Git\Python\Project\connect.db'
# app.config.DB_NAME='connect.db'

@app.route('/')
async def test(req):
    return text('Hello World!')

@app.get("/user")
async def getAllUserInfo(req):
    user=[]
    async with aiosqlite.connect(dbName) as db:
        async with db.execute("select username,password,Bandwidth from user") as cusor:
            async for row in cusor:
                tmp = {'username': row[0], 'passwd': row[1], 'Bandwidth': row[2]}
                user.append(tmp)
    return json(user)

@app.get('/user/<username>')
async def getOneUserInfo(req,username):
    async with aiosqlite.connect(dbName) as db:
        async with db.execute(f"select username,password,Bandwidth from user where username=\'{username}\'") as cusor:
            async for row in cusor:
                tmp = {'username': row[0], 'password': row[1], 'Bandwidth': row[2]}
                return json(tmp)

@app.post("/user")
async def addUser(req):
    username=req.json.get('username')
    password=req.json.get('password')
    Bandwidth=req.json.get('Bandwidth')
    print(f"username:{username},password:{password},Bandwidth:{Bandwidth}")
    try:
        async with aiosqlite.connect(dbName) as db:
            await db.execute(f"insert into user values(\'{username}\',\'{password}\',\'{Bandwidth}\')")
            await db.commit()
    except Exception as e:
        return text(f"{e}. when add new user {username}",status=500)
    return text(f"Successfully add new user {username}")

@app.put('/user/<username>')
async def updateUser(req, username):
    oldPassword = req.json.get('oldPassword')
    newPassword = req.json.get('newPassword')
    newBandwidth= req.json.get('newBandwidth')
    print(f"oldPassword:{oldPassword},newPassword:{newPassword},newBandwidth:{newBandwidth}")
    async with aiosqlite.connect(dbName) as db:
        async with db.execute(f"select password from user where username=\'{username}\'")as cusor:
            async for row in cusor:
                if row[0] != oldPassword:
                    return text("password can not match. You have no right to update", status=405)
                else:
                    if not newBandwidth and newPassword:
                        await db.execute(f"update user set password=\'{newPassword}\'where username=\'{username}\'")
                    elif not newPassword and newBandwidth:
                        await db.execute(f"update user set Bandwidth=\'{newBandwidth}\' where username=\'{username}\'")
                    elif newPassword and newBandwidth:
                        await db.execute(f"update user set Bandwidth=\'{newBandwidth}\',password=\'{newPassword}\' where username=\'{username}\'")
                    else:
                        return text(f"Successfully update user: {username}.but you update nothing.")
                    await db.commit()
                    return text(f"Successfully update user: {username}")
            else:
                return text(f"Can not find user: {username}",status=404)

@app.delete('/user/<username>') #删除用户
async def delete_user(req, username):
    password = req.json.get('password')
    async with aiosqlite.connect(dbName) as db:
        async with db.execute(f"select password from user where username=\'{username}\'")as cusor:
            async for row in cusor:
                if row[0] != password:
                    return text("password can not match. You have no right to delect", status=405)
                else:
                    await db.execute(f"delete from user where username=\'{username}\'")
                    await db.commit()
                    return text(f"Successfully update user: {username}")
            else:
                return text(f"Can not find user: {username}",status=404)

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=8000)

```
